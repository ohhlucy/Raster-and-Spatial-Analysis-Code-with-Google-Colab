# -*- coding: utf-8 -*-
"""Raster and Spatial Analysis Code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eFzAEmqNcIfTHaYjw4iMCwWd5SzTLgog
"""

!pip install cartopy
import cartopy

import numpy as np
import matplotlib
import matplotlib.pyplot as plt

!apt-get -qq install -y graphviz && pip install pydot
import pydot

!apt-get -qq install -y libarchive-dev && pip install -U libarchive
import libarchive

!pip install matplotlib-venn

!apt-get -qq install -y libfluidsynth1

# pip install gspread for google sheet import, pyproj for pyproj.transform
!pip install --upgrade -q pyproj

# import various library
import os
import pandas as pd
import pyproj
import re

#Installations
!apt install gdal-bin python-gdal python3-gdal 
!pip install rasterio
!apt install python3-rtree 
!pip install git+git://github.com/geopandas/geopandas.git
!pip install descartes

import rasterio as rio
from rasterio.plot import show

import ee

!pip install geemap

import csv
import datetime
import io
import json
import math
import os
import requests
import shutil
import tarfile
import urllib.request
import warnings
import zipfile

import ipywidgets as widgets
from IPython.display import display, IFrame
from ipytree import Node, Tree

import geemap.foliumap as geemap
Map = geemap.Map(center=[40,-100], zoom=4)
Map

# basic NOMADS OpenDAP extraction and plotting script

import numpy as np
import matplotlib.pyplot as plt
import netCDF4

# set up the figure
plt.figure()

# set up the URL to access the data server.
# See the NWW3 directory on NOMADS 
# for the list of available model run dates.

mydate='20221120'
url='//nomads.ncep.noaa.gov:9090/dods/wave/nww3/nww3'+ \
    mydate+'/nww3'+mydate+'_00z'

# Extract the significant wave height of combined wind waves and swell

!apt update -q
!apt-get install -q openjdk-11-jdk-headless
!curl -L https://github.com/SpencerPark/IJava/releases/download/v1.3.0/ijava-1.3.0.zip -o ijava-kernel.zip
!unzip -q ijava-kernel.zip -d ijava-kernel && cd ijava-kernel && python3 install.py --sys-prefix
!jupyter kernelspec list

pip install rasterio

pip install --no-use-pep517 --global-option -I<path to gdal include files> -lgdal_i -L<path to gdal library>

print('Landsat on Google:')
filepath = 'https://storage.googleapis.com/gcp-public-data-landsat/LC08/01/044/034/LC08_L1GT_044034_20130330_20170310_01_T2/LC08_L1GT_044034_20130330_20170310_01_T2_B1.TIF'
with rasterio.open(filepath) as src:
    print(src.profile)

!sudo apt-get install libkrb5-dev

!pip install arcgis==1.8.4 torch==1.4.0 fastai==1.0.60

import cv2 as cv 
from google.colab.patches import cv2_imshow # for image display
from skimage import io
from PIL import Image

# Create a list to store the urls of the images
urls = ["https://courses.neteler.org/wp-content/uploads/2014/11/landsat8_pansharpended_1nov2014_trentino.png",
       "https://courses.neteler.org/wp-content/uploads/2014/11/landsat8_pansharpended_1nov2014_s_michele.jpg",
      "https://courses.neteler.org/wp-content/uploads/2014/11/landsat8_pansharpended_1nov2014_zoom.png"]  
# Read and display the image
# loop over the image URLs, you could store several image urls in the list

for url in urls:
  image = io.imread(url) 
  image_2 = cv.cvtColor(image, cv.COLOR_BGR2RGB)
  final_frame = cv.hconcat((image, image_2))
  cv2_imshow(final_frame)
  print('\n')

#!pip install netCDF4

import warnings
warnings.filterwarnings('ignore')

import datetime
import numpy as np
import netCDF4 as nc4

ncFileName = 'sample_netcdf.nc4'
modeType   = 'w'
fileFormat = 'NETCDF4'
ncfid = nc4.Dataset(ncFileName, mode=modeType, format=fileFormat)

time = ncfid.createDimension('time', None)
lev  = ncfid.createDimension('lev', 72)
lat  = ncfid.createDimension('lat', 91)
lon  = ncfid.createDimension('lon', 144)

from osgeo import gdal
import matplotlib.pyplot as plt
  
  
dataset = gdal.Open(r'LC08_01_044_034_LC08_L1GT_044034_20130330_20170310_01_T2_LC08_L1GT_044034_20130330_20170310_01_T2_B1.TIF')

## TODO: LOAD IMAGE
## url = 
## myImg = io.imread(url)  
## cv2_imshow(cv.cvtColor(myImg, cv.COLOR_BGR2RGB))

# Check the image matrix data type (could know the bit depth of the image)
print(image.dtype)
# Check the height of image 
print(image.shape[0])
# Check the width of image 
print(image.shape[1])
# Check the number of channels of the image
print(image.shape[2])

plt.hist(image.ravel(),bins = 256, range = [0,256]) 
plt.show()

color = ('b','g','r')
for i,col in enumerate(color):
    histr = cv.calcHist([image],[i],None,[256],[0,256])
    plt.plot(histr,color = col)
    plt.xlim([0,256])
plt.show()

gray_image = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
cv2_imshow(gray_image)

# Plot the histogram of the gray image. We could observe that the frequency of
# the image hist has decreased ~ 1/3 of the histogram of color image
plt.hist(gray_image.ravel(),bins = 256, range = [0, 256])
plt.show()

#myGrayImg = cv.cvtColor(myImg, cv.COLOR_BGR2GRAY)
#cv2_imshow()

plt.contour(gray_image, origin = "image")

# This is an inverse operation of the grayscale image, you could see that the
# bright pixels become dark, and the dark pixels become bright
im2 = 255 - gray_image
cv2_imshow(im2)

# Another transform of the image, after adding a constant, 
# all the pixels become brighter and a hazing-like effect of the image is generated
im3 = (100.0/255)*gray_image + 100
cv2_imshow(im3)

# The lightness level of the gray_image decreases after this step
im4 = 255.0*(gray_image/255.0)**2
cv2_imshow(im4)

# Since Python is object oriented, you can explore the contents of the NOMADS
# data set by examining the file object, such as file.variables.

# The indexing into the data set used by netCDF4 is standard python indexing.
# In this case we want the first forecast step, but note that the first time 
# step in the RTOFS OpenDAP link is all NaN values.  So we start with the 
# second timestep

#There are known problems with netCDF4 and source image code
#Will need to review packages above to ensure TIFF images can be read as well as url files.

# Plot the field using Basemap.  Start with setting the map
# projection using the limits of the lat/lon data itself:

# convert the lat/lon values to x/y projections.

# plot the field using the fast pcolormesh routine 
# set the colormap to jet.

# Add a coastline and axis values.

# Add a colorbar and title, and then show the plot.